/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pushing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:09:54 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/21 21:12:24 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	push(t_stack_node **dst, t_stack_node **src) //Define a function that pushes a top node, from one stack to another's top node
{
	t_stack_node	*push_node; //Used to store the pointer to the node to be pushed

	if (!*src) //The top node of a stack to be pushed
		return ;
	push_node = *src; //The top node to push is assigned to the `t_stack_node` variable
	*src = (*src)->next; //Move the pointer of the stack to the next node, which will become the next `top node` after the node before is "popped off"
	if (*src) //Check if the current node exists
		(*src)->previous = NULL; //Set the current node as the head of the stack
	push_node->previous = NULL; //Detach the node to push from its stack
	if (!*dst) //Check if the other stack is empty
	{
		*dst = push_node; //If it's empty, assign as the first node of that stack, the node we want pushed
		push_node->next = NULL; //Ensure it is also set as the last node, e.g. properly null terminate the stack
	}
	else //If the other stack we want to push to is not empty
	{
		push_node->next = *dst; //Assign the node to push, to the top of the current top node of the stack
		push_node->next->previous = push_node; //Assign to the "second node" `prev` attribute, the pushed node as the current top node
		*dst = push_node; //Complete appending the node. The pointer to the top node of the stack is now pointing to our recently pushed node
	}
}

void	pa(t_stack_node **a, t_stack_node **b, int testing)
{
	push(a, b);
	if (!testing)
		ft_putstr("pa\n");
}

void	pb(t_stack_node **a, t_stack_node **b, int testing)
{
	push(b, a);
	if (!testing)
		ft_putstr("pb\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rotating.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:58:24 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 18:23:28 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

// void	ft_rotate_node(t_stack_node **head)
// {
// 	t_stack_node	*last;

// 	if (!*head || !(*head)->next)
// 		return ;
// 	last = last_node(head); // Dereference `head` to pass the correct type
// 	last->next = (*head);
// 	(*head) = (*head)->next;
// 	(*head)->previous = NULL;
// 	last->next->previous = last;
// 	last->next->next = NULL;
// }

void	ft_rotate_node(t_stack_node **stack) //Define a function that rotates the stack's top node to the bottom of the stack
{
	t_stack_node	*last_node1; //To store a pointer to the last node of a stack

	if (!*stack || !(*stack)->next) //Check if the stack is empty, or if there's one node
		return ;
	last_node1 = last_node(*stack); 
	last_node1->next = *stack; //Assign to the last node, its `next` attribute as the top node, effectively setting the current top node as the last node
	*stack = (*stack)->next; //Assign to the pointer of the top node, the node after it (second from the top)
	(*stack)->previous = NULL; //Complete setting the current top node by detaching it from its previous top node
	last_node1->next->previous = last_node1; //Reconnect the second node's prev pointer to point to what was previously the last node in the stack
	last_node1->next->next = NULL; //Assign to the `next` attribute of the current last node, `NULL` effectively setting it as the current last node, and properly null terminating the stack
}	

void	ra(t_stack_node **a, int testing)
{
	ft_rotate_node(a);
	if (!testing)
		ft_putstr("ra\n");
}

void	rb(t_stack_node **b, int testing)
{
	ft_rotate_node(b);
	if (!testing)
		ft_putstr("rb\n");
}

void	rr(t_stack_node **a, t_stack_node **b, int testing)
{
	ft_rotate_node(a);
	ft_rotate_node(b);
	if (!testing)
		ft_putstr("rr\n"); // Changed from "rrr\n"
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rrotating.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:02:59 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/21 21:01:28 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

// void	ft_rev_rotate_node(t_stack_node **head)
// {
// 	t_stack_node	*last;

// 	if (!*head || !(*head)->next)
// 		return ;
// 	last = last_node(head);
// 	last->previous->next = NULL;
// 	last->previous = NULL;
// 	last->next = (*head);
// 	(*head) = last;
// 	last->next->previous = last;
// }

void ft_rev_rotate_node(t_stack_node **stack)
{
	t_stack_node	*last; //To store the pointer to the last node

	if (!*stack || !(*stack)->next) //Check if the stack is empty, or if there's one node
		return ;
	last = last_node(*stack);
	last->previous->next = NULL; //Assign to the `next` attribute of the node before itself, `NULL` effectively setting it as the current last node
	last->next = *stack; //Assign to its own `next` attribute as the top node of the stack
	last->previous = NULL; //Detach itself from the node before it
	*stack = last;  //Complete appending itself to the top of the stack, and now holds the pointer to the top node
	last->next->previous = last; //Update the current last node of the stack
}

void	rra(t_stack_node **a, int testing)
{
	ft_rev_rotate_node(a);
	if (!testing)
		ft_putstr("rra\n");
}

void	rrb(t_stack_node **b, int testing)
{
	ft_rev_rotate_node(b);
	if (!testing)
		ft_putstr("rrb\n");
}

void	rrr(t_stack_node **a, t_stack_node **b, int testing)
{
	ft_rev_rotate_node(a);
	ft_rev_rotate_node(b);
	if (!testing)
		ft_putstr("rrr\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   swaping.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:09:00 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 17:20:15 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

// void	ft_swap_node(t_stack_node **head)
// {
// 	t_stack_node	*tmp;
// 	t_stack_node	*prev_1;
// 	t_stack_node	*next_1;

// 	if (!(*head) || !((*head)->next))
// 		return ;
// 	tmp = *head;
// 	prev_1 = (*head)->previous;
// 	next_1 = (*head)->next->next;
// 	(*head) = (*head)->next;
// 	(*head)->next = tmp;
// 	(*head)->previous = prev_1;
// 	tmp->next = next_1;
// 	tmp->previous = *head;
// 	if (next_1)
// 		next_1->previous = tmp;
// 	if (prev_1)
// 		prev_1->next = *head;
// }

void	ft_swap_node(t_stack_node **head)
{
	if (!*head || !(*head)->next) //Check if the stop node, or second node of a stack exists
		return ;
	*head = (*head)->next; //Update `head` to point to the next node, effectively swapping the first and second nodes
	(*head)->previous->previous = *head; //Update the `prev` pointer of the node before the `new head` to point to the `new head`
	(*head)->previous->next = (*head)->next; //Update the `next` pointer of the node before the `new head` to skip the `old head` and point directly to the `new head`
	if ((*head)->next) //Check if there's a `next` node after the `new head` and
		(*head)->next->previous = (*head)->previous; //If so, update its `prev` pointer to point back to the `new head`
	(*head)->next = (*head)->previous; //Update the `next` pointer of the `new head` to point to the `old head`, effectively reversing their positions
	(*head)->previous = NULL; //Sets the `prev` pointer of the `new head` to `NULL` completing the swap
}

void	sa(t_stack_node **a, int testing)
{
	ft_swap_node(a);
	if (!testing)
		ft_putstr("sa\n");
}

void	sb(t_stack_node **b, int testing)
{
	ft_swap_node(b);
	if (!testing)
		ft_putstr("sb\n");
}

void	ss(t_stack_node **a, t_stack_node **b, int testing)
{
	ft_swap_node(a);
	ft_swap_node(b);
	if (!testing)
		ft_putstr("ss\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft_tools.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 15:31:13 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 19:09:03 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

int	ft_strlen(const char *s)
{
	size_t	i;

	i = 0;
	while (s[i])
		i++;
	return (i);
}

int	stack_length(t_stack_node *stack)
{
	int	i;

	i = 0;
	if (!stack)
		return (0);
	while (stack)
	{
		i++;
		stack = stack->next;
	}
	return (i);
}

t_stack_node	*last_node(t_stack_node *stack)
{
	if (!stack)
		return (NULL);
	while (stack->next)
		stack = stack->next;
	return (stack);
}

// t_stack_node	*ft_lstnew(void *content)
// {
// 	t_stack_node	*new;

// 	new = malloc(sizeof(t_stack_node));
// 	if (!new)
// 		return (NULL);
// 	new->value = content;
// 	new->next = NULL;
// 	return (new);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   split.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 15:32:26 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 19:06:15 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

// int	ft_isdigit(int c)
// {
// 	return (c >= '0' && c <= '9');
// }

// static int	count_words(char *s, char c)
// {
// 	int	count;
// 	int	inside_word;

// 	count = 0;
// 	inside_word = 0;
// 	while (*s)
// 	{
// 		if (*s == c)
// 			inside_word = 0;
// 		else if (!inside_word)
// 		{
// 			inside_word = 1;
// 			count++;
// 		}
// 		s++;
// 	}
// 	return (count);
// }

// static char	*get_next_word(char *s, char c, int *cursor)
// {
// 	char	*next_word;
// 	int		len;
// 	int		i;

// 	i = 0;
// 	len = 0;
// 	while (s[*cursor] == c)
// 		(*cursor)++;
// 	while (s[*cursor + len] != c && s[*cursor + len])
// 		len++;
// 	next_word = malloc((len + 1) * sizeof(char));
// 	if (!next_word)
// 		return (NULL);
// 	while (i < len)
// 		next_word[i++] = s[(*cursor)++];
// 	next_word[i] = '\0';
// 	return (next_word);
// }

// char	**ft_split(char *s, char c)
// {
// 	int		words_count;
// 	char	**result_array;
// 	int		i;
// 	int		cursor;

// 	i = -1;
// 	cursor = 0;
// 	if (!s)
// 		return (NULL);
// 	words_count = count_words(s, c);
// 	result_array = malloc((words_count + 1) * sizeof(char *));
// 	if (!result_array)
// 		return (NULL);
// 	while (++i < words_count)
// 	{
// 		result_array[i] = get_next_word(s, c, &cursor);
// 		if (!result_array[i])
// 		{
// 			while (--i > 0)
// 				free(result_array[i]);
// 			return (free(result_array), NULL);
// 		}
// 	}
// 	result_array[i] = NULL;
// 	return (result_array);
// }


//See notes below, why we had to create a "mutable" ft_split, rather than using our libft version

//#include <stdbool.h>

static int	count_words(char *s, char c) //Define a function that returns the substrings count in a string seperated by a delimiter
{
	int		count; //To store the substring count
	int	inside_word; //A flag to indicate whether we are inside a substring or a delimeter

	count = 0;
	while (*s) //Loop until the end of the string is reached
	{
		inside_word = 0; //Set the bool to false to start the loop
		while (*s == c) //While the current character is the delimeter
			++s; //Move to the next character
		while (*s != c && *s) //While the current character is not a deilimeter and the end of the string is not reached, 
		{
			if (!inside_word) //If we are not currently inside the substring
			{
				++count; //Increment the count as we are about to move inside a substring
				inside_word = 1; //Set the bool to true, indicating we've found a substring
			}
			++s; //Move to the next character of the string
		}
	}
	return (count);
}

static char	*get_next_word(char *s, char c) //Define a function that returns the new substring found within a string
{
	static int	cursor = 0; //To keep track of the position within the string `s` across multiple function calls, needed to continue processing the string from where we left off in previous calls, essential for tokenizing a string
	char		*next_word; //To store a pointer of the new substring
	int			len; //To store the length of the substring being extracted
	int			i; //Used for indexing characters in the new substring

	len = 0;
	i = 0;
	while (s[cursor] == c) //Skip past any consecutive delimiter characters at the current position in the string
		++cursor;
	while ((s[cursor + len] != c) && s[cursor + len]) //Calculate the length of the substring by counting characters until either a delimiter or the end of the string is encountered
		++len;
	next_word = malloc((size_t)len * sizeof(char) + 1); //Allocate memory for new substring based on its length plus one byte for the null terminator
	if (!next_word) //Check for unsuccessful memory allocation
		return (NULL);
	while ((s[cursor] != c) && s[cursor]) //Loop until a delimeter is encountered and the end of the string is reached
		next_word[i++] = s[cursor++]; //Copy each character from the string to the new substring and increment `i` and `cursor` after each character
	next_word[i] = '\0'; //Properly null terminate the newly created substring
	return (next_word);
}

char **split(char *s, char c) //Define a function that returns the substrings in a string seperated by a delimiter
{
	int		words_count; //Used to keep track of the number of substrings in the string
	char	**result_array; //To store a pointer to pointers, the array of all the substrings
	int		i; //Used to iterate through the array

	i = 0;
	words_count = count_words(s, c);
	if (!words_count) //Check for `0` words
		exit(1);
	result_array = malloc(sizeof(char *) * (size_t)(words_count + 2)); //Allocate memory for the result_array based on the number of words (words_count) plus two additional slots to account for the null terminator at the end of the last string, and to null terminate the entire array
	if (!result_array) //Check for unsuccessful memory allocation
		return (NULL);
	while (words_count-- >= 0) //Iterates through the words to be split all words have been processed
	{
		if (i == 0) //Check if the first character of the input string is the delimiter
		{
			result_array[i] = malloc(sizeof(char)); //Allocate memory for an empty string (a single null terminator)
			if (!result_array[i]) ////Check for unsuccessful memory allocation
				return (NULL);
			result_array[i++][0] = '\0'; //Include in the result array as distinct elements
			continue ;
		}
		result_array[i++] = get_next_word(s, c); //If the first character of the string is not a delimeter, extract the substring and copy it into the result array
	}
	result_array[i] = NULL; //Properly null terminate the array
	return (result_array);
}


/*
 Both functions, `ft_split()` `split()` split a string into an array of substrings using a specified delimiter character. 
 However, the differences are:

 #1	Function Signature:
	- `ft_split` takes a constant string (const char *s) as input.
	- `split` takes a mutable string (char *s) as input.

#2	Input Mutability:
	- `ft_split` takes a constant string (const char *s) as input, indicating that it does not modify the input string.
	- `split` takes a mutable string (char *s) as input, indicating it may modify the input string during tokenization.
	- Mutable strings can be modified in-place, meaning you can change the characters within the string without creating 
	  a new string object.
	- Immutable strings, on the other hand, cannot be modified once they are created. Any operation that appears to modify 
	  an immutable string actually creates a new string with the desired changes.

#TOKENIZATION:
	- Tokenization is the process of breaking down a text or a sequence of characters into smaller units called tokens. 
	- Tokens are typically words, phrases, symbols, or other meaningful elements within the text.
	- In the case of push_swap,  Word tokenization is the process of splitting text into words or word-like units. 
	  It involves identifying word boundaries and separating words from each other. For example, in the sentence "Tokenization 
	  is important," the words "Tokenization," "is," and "important" are individual tokens.
	- Purpose: 
	  Tokenization is a preprocessing step that simplifies text analysis tasks. 
	  It allows text to be represented in a form that can be easily processed by algorithms and models. 

#3	Memory Management:
	- `ft_split` allocates memory for the resulting string array and the individual substrings within the function, 
	  and frees memory
	- `split` also allocates memory for the resulting string array and substrings but relies on the caller to free the memory.

#4	Static Variable Usage:
	- `ft_split` does not use static variables in its implementation.
	- `split` uses a static variable cursor to keep track of the position in the input string for tokenization.

#5	Error Handling:
	- `ft_split` returns NULL if memory allocation fails during the tokenization process.
	- `split` exits the program with an error code if the number of words is zero.

In summary, both functions perform string tokenization, but they have differences in terms of input mutability, memory 
management, and error handling. 
*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validating.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 16:19:21 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 15:30:19 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

int	syntax_error(char *str_n) //Define a funtion to handle syntax errors, and returns `1` for `error` should any of the following conditions are met
{
	if (!(*str_n == '+'
			|| *str_n == '-'
			|| (*str_n >= '0' && *str_n <= '9'))) //Check if the first character of the input string does not contain a sign or a digit
		return (1);
	if ((*str_n == '+'
			|| *str_n == '-')
		&& !(str_n[1] >= '0' && str_n[1] <= '9')) //Check if the first character of the input string contains a sign, but the second character does not contain a digit
		return (1);
	while (*++str_n) //If the error conditions above are passed, pre-increment to point to the next character in the string, and loop until the end of the string is reached
	{
		if (!(*str_n >= '0' && *str_n <= '9')) //Check if the next character in the string is not a digit
			return (1);
	}
	return (0);
}

int	error_duplicate(t_stack_node *a, int n) //Define a function that checks for duplicate input numbers in stack `a`
{
	if (!a) //Check for an empty stack
		return (0);
	while (a) //Loop until the end of stack `a` is reached
	{
		if (a->value == n) //Check if the current node's value is equal to `n`. Refer to `init_stack_a()`
			return (1);
		a = a->next; //Move to the next node to check for duplicates
	}
	return (0);
}

void	free_stack(t_stack_node **stack) //Define a function to free a stack if there are errors
{
	t_stack_node	*tmp; //To store the next node in the stack before the current node is freed, because once a node is freed, you can't access its next pointer
	t_stack_node	*current;

	if (!stack) //Check for an empty stack
		return ;
	current = *stack;
	while (current) //As long as a node exist in the stack
	{
		tmp = current->next; //Assign to `tmp` the pointer to the next node
		current->value = 0; //Assigning the node to `0` before freeing is not strictly necessary but it can help catch potential bugs such as memory-leaks and improve debugging
		free(current); //Free the current node, deallocating the memory occupied by that node
		current = tmp; //Assign `tmp` as the current first node
	}
	*stack = NULL;
}

void	free_error(t_stack_node **a) //Define a function that, upon encountering a unique error, to free the stack and print an error message
{
	free_stack(a);
	ft_putstr("Error\n");
	exit(1);
}

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	return (0);
}
// long ft_atol(const char *s, t_stack_node **a) 
// {
//     long result = 0;
//     int sign = 1;
//     int i = 0;

//     while (s[i] == ' ' || (s[i] >= '\t' && s[i] <= '\r'))
//         i++;
//     if (s[i] == '+' || s[i] == '-') 
//     {
//         if (s[i] == '-')
//             sign = -1;
//         i++;
//     }
//     if (!ft_isdigit(s[i]))
//         free_error(a);
//     while (s[i] >= '0' && s[i] <= '9') 
//     {
//         result = result * 10 + (s[i] - '0');
//         if ((sign == 1 && result > INT_MAX) || (sign == -1 && -result < INT_MIN))
//             free_error(a);
//         i++;
//     }
//     return (result * sign);
// }
long	ft_atol(const char *s) //Define a function that converts every string into a long value
{
	long	result;
	int		sign;

	result = 0;
	sign = 1; 
	while (*s == ' ' || *s == '\t' || *s == '\n' || \
			*s == '\r' || *s == '\f' || *s == '\v')
		s++;
	if (*s == '-' || *s == '+')
	{
		if (*s == '-')
			sign = -1;
		s++;
	}
	while (ft_isdigit(*s))
		result = result * 10 + (*s++ - '0');
	return (result * sign);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialiase_a_2_b.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:21:38 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 19:31:42 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	current_index(t_stack_node *stack)
{
	int	i; //To store the index of the current node
	int	median; //To store the position of the median of the stack

	i = 0; //The first index is `0`
	if (!stack) //Check for am empty stack
		return ;
	median = len_stack(stack) / 2; //Calculate the median by dividing the length of a stack by 2
	while (stack) //Loop through all the nodes until the end of the stack is reached
	{
		stack->indexing = i; //Assign the current index value to the current node
		if (i <= median) //Check whether the current node is above or below the median
			stack->above_median_line = 1; //If above, set the above_median data of the node to true
		else
			stack->above_median_line = 0; //If below, set the above_median data of the node to false
		stack = stack->next; //Move to the next node for indexing
		++i; //Increment the index value to set the next node with
	}
}


void	set_target_a(t_stack_node *a, t_stack_node *b)
{
	t_stack_node	*current_b; //To store the pointer to the current node in stack `b` and iterate through each node following
	t_stack_node	*target_node; //To store the pointer to the target node in stack `b`
	long			best_match_index; //In this case, the best match indexe stores the value of the "closest smaller number" so far

	while (a) //As long as we have nodes in stack `a`
	{
		best_match_index = LONG_MIN; //Assign the smallest `long` as the closest smaller number so far
		current_b = b; //Assign to `current_b` the current `b` node
		while (current_b) //Iteratively search through all the nodes in stack `b` until the end of the stack is reached
		{
			if (current_b->value < a->value 
				&& current_b->value > best_match_index) //Check if `b` node is smaller than `a` node && bigger than the closest smaller number so far
			{
				best_match_index = current_b->value; //If so, update the value of the closest smaller number so far
				target_node = current_b; //Assign the current `b` node as the `target_node`
			}
			current_b = current_b->next; //Move to the next `b` node for comparison, until a "closer smaller number" is found
		}
		if (best_match_index == LONG_MIN) //Check if the LONG_MIN hasn't changed, it means we haven't found anything smaller
			a->target_node = find_max_node(b); //If so, find the biggest `nbr` and set this as the target node
		else
			a->target_node = target_node; //If no "closer smaller number" is found, and the best match has changed
		a = a->next; //Move to the next `a` node to find it's target `b` node
	}
}
 void	cost_analysis_a(t_stack_node *a, t_stack_node *b) //Define a functio that analyses the cost of the `a` node along with it's target `b` node, which is the sum of the number of instructions for both the nodes to rotate to the top of their stacks
{
	int	len_a; //To store the length of stack `a`
	int	len_b; //To store the length of stack `b`

	len_a = len_stack(a);
	len_b = len_stack(b);
	while (a) //Loop through each node until the end of the stack is reached
	{
		a->push_cost = a->indexing; //Assign the current `a` node's push cost, its' index value
		if (!(a->above_median_line)) //Check if the above_median data is false, meaning it is below median
			a->push_cost = len_a - (a->indexing); //If so, update `a` node's push cost to the stack's length - index
		if (a->target_node->above_median_line) //Check if `a` node's target node `b` has a "true" above median attribute, meaning the target `b` node is above median
			a->push_cost += a->target_node->indexing; //If so, update `a` node's push cost, the sum of (its current index) + (its target `b` node's index)
		else //If `a` node is indeed above median and its target `b` node is below median
			a->push_cost += len_b - (a->target_node->indexing); //Update `a` node's push cost, the sum of (its current index) + (`b` stack's length - its target `b` node's index)
		a = a->next; //Move to the next `a` node for its cost analysis
	}
}

void	init_node_a(t_stack_node *a, t_stack_node *b)
{
	current_index(a);
	current_index(b);
	set_target_a(a, b);
	cost_analysis_a(a, b);
	set_cheapest_node(a);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialiase_b_2_a.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:29:46 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/21 21:12:53 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

 void	set_target_b(t_stack_node *a, t_stack_node *b) //Define a function that sets for the current `a` node, its target node from stack `a`
{
	t_stack_node	*current_a; //To store the pointer to the current `a` node
	t_stack_node	*target_node; //To store the pointer of the target node for `b` node
	long			best_match_index; //To store the "closest bigger" number so far

	while (b)
	{
		best_match_index = LONG_MAX; //Set the current best match to the max long
		current_a = a; //Assign the pointer to point to the current `a` node
		while (current_a) //While the pointer is not set to NULL
		{
			if (current_a->value > b->value 
				&& current_a->value < best_match_index) //Check if the `a` node's value is bigger than `b` node, && smaller than the "closest bigger" so far
			{
				best_match_index = current_a->value; //Set the best match as the value in the current `a` node
				target_node = current_a; //Set `b` node's target node pointer to point to the current `a` node
			}
			current_a = current_a->next; //Move to the next `a` node for processing
		}
		if (best_match_index == LONG_MAX) //If the best match value has not changed
			b->target_node = find_min_node(a); //Set `b` node's target node pointer to point to the smallest number in stack `a`
		else
			b->target_node = target_node; //If the best match value has been updated, then we have a target node for the current `b` node
		b = b->next; //Move to the next `b` node for processing
	}
}

void	init_nodes_b(t_stack_node *a, t_stack_node *b)
{
	current_index(a);
	current_index(b);
	set_target_b(a, b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_helpers.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:32:04 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/21 17:55:04 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	ft_putstr(char *str)
{
	while (*str)
	{
		write(1, str, 1);
		str++;
	}
}

int	len_stack(t_stack_node *stack)
{
	int	i;

	i = 0;
	if (!stack)
		return (0);
	while (stack)
	{
		i++;
		stack = stack->next;
	}
	return (i);
}

int stack_sorted(t_stack_node *stack)
{
	if (!stack)
		return (1);
    while (stack->next)
    {
        if (stack->value > stack->next->value)
            return (0);
        stack = stack->next;
    }
    return (1);
}

t_stack_node	*find_min_node(t_stack_node *stack)
{
	t_stack_node	*min_node;
	long			min_number;

	min_number = LONG_MAX;
	if (!stack)
		return (NULL);
	while (stack)
	{
		if (stack->value < min_number)
		{
			min_number = stack->value;
			min_node = stack;
		}
		stack = stack->next;
	}
	return (min_node);
}

t_stack_node	*find_max_node(t_stack_node *stack)
{
	t_stack_node	*max_node;
	long			max_number;

	max_number = LONG_MIN ;
	if (!stack)
		return (NULL);
	while (stack)
	{
		if (max_number < stack->value)
		{
			max_number = stack->value;
			max_node = stack;
		}
		stack = stack->next;
	}
	return (max_node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_helpers2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:36:00 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 19:22:22 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	append_node(t_stack_node **stack, int n) //Define a function that searches for the last node to append to the linked list
{
	t_stack_node	*node; //To store a pointer to the new node to be created with the value `n`
	t_stack_node	*last_node1; //To store a pointer to the current last node of the stack

	if (!stack)
		return ;
	node = malloc(sizeof(t_stack_node)); //Allocate memory for the new node
	if (!node)
		return ;
	node->next = NULL; //Set the next pointer of the new node to NULL because it will be the last node in the list
	node->value = n; //Set the `next` data of of the new node to `n` value
	node->cheapest = 0; // Initialise chaepest to 0;
	// other elements in the struct could be initialised as well but for now, this was the only one causing a valgrind issue
	if (!(*stack)) //Check if the stack is empty or currently pointing to NULL, indicating a first node needs to be found
	{
		*stack = node; //If empty, update the pointer *stack to point to the node, effectively making it the new head of the linked list
		node->previous = NULL; //Set the head node's previous pointer to NULL as it's the first node
	}
	else //If the stack is not empty, it means there are existing nodes in the linked list
	{
		last_node1 = last_node(*stack); //In which case, find the last node
		last_node1->next = node; //Append the new node to the last node
		node->previous = last_node1; //Update the previous pointer of the new node and complete the appending
	}
}

void	init_stack_a(t_stack_node **a, char **av)
{
	long	nmr;
	int		number;
	int		i;

	i = 0;
	while (av[i])
	{
		if (syntax_error(av[i]))
			free_error(a);
		nmr = ft_atol(av[i]);
		if (nmr < INT_MIN || nmr > INT_MAX)
			free_error(a);
		number = (int)nmr;
		if (error_duplicate(*a, number))
			free_error(a);
		append_node(a, number);
		i++;
	}
}



void	set_cheapest_node(t_stack_node *stack) //Define a function that sets a node's `cheapest` attribute as `true` or `false`
{
	long			cheapest_value; //To store the value of the cheapest node so far
	t_stack_node	*cheapest_node; //To store a pointer to the cheapest node so far

	if (!stack) //Check for an empty stack
		return ;
	cheapest_value = LONG_MAX; //Assign the biggest `long` as the cheapest value so far
	while (stack) //Loop through every node until the end of the stack is reached, and we find the cheapest node
	{
		if (stack->push_cost < cheapest_value) //Check if the current node's push cost is cheaper than the cheapest value so far
		{
			cheapest_value = stack->push_cost; //If so, update the cheapest value to the current node's push cost
			cheapest_node = stack; //Assign the current node as the cheapest node so far
		}
		stack = stack->next; //Move to the next node for comparison
	}
	cheapest_node->cheapest = 1; //After iterating through the stack, if no cheaper node is found than the current, then set the cheapest node's `cheapest` attribut to `true` in the data structure
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   three_sort.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:18:08 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/21 20:00:10 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	min_on_top(t_stack_node **a)
{
	while ((*a)->value != find_min_node(*a)->value)
	{
		if (find_min_node(*a)->above_median_line)
			ra(a, 0);
		else
			rra(a, 0);
	}
}

void	sort_three(t_stack_node **a)
{
	t_stack_node	*biggest_node; //To store a pointer to the biggest node in stack `a`

	biggest_node = find_max_node(*a);
	if (biggest_node == *a) //Check if the current node is the biggest
		ra(a, 0); //If so, rotate the top node to the bottom of the stack
	else if ((*a)->next == biggest_node) //Check if the second node is the biggest
		rra(a, 0); //If so, reverse rotate the bottom node, to the top of the stack
	if ((*a)->value > (*a)->next->value) //Check if the bottom node is the biggest, but the top node is higher than the second node
		sa(a, 0); //If so, simply swap the top and second nodes
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   turk_sort.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:20:41 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 19:32:11 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	rotate_a_n_b(t_stack_node **a,
						t_stack_node **b,
						t_stack_node *cheapest_node)
{
	while (*b != cheapest_node->target_node
		&& *a != cheapest_node) //As long as the current `b` node is not `a` cheapest node's target node, and the current top `a` node is not the top node
		rr(a, b, 0); //Rotate both `a` and `b` nodes
	current_index(*a);
	current_index(*b);
}

void	rev_rotate_a_n_b(t_stack_node **a,
						t_stack_node **b,
						t_stack_node *cheapest_node)
{
while (*b != cheapest_node->target_node
		&& *a != cheapest_node) //As long as the current `b` node is not `a` cheapest node's target node && and the current `a` node is not the cheapest
		rrr(a, b, 0); //Reverse rotate both `a` and `b` nodes
	current_index(*a); //Refresh current node positions
	current_index(*b);

}

t_stack_node	*get_cheapest(t_stack_node *stack) //Define a function that searches for the cheapest node, that is set by bool
{
	if (!stack)
		return (NULL);
	while (stack)
	{
		if (stack->cheapest)
			return (stack);
		stack = stack->next;
	}
	return (NULL);
}

void	prep_for_push(t_stack_node **stack,
						t_stack_node *top_node,
						char stack_name) //Define a function that moves the required node to the top of the stack
{
	while (*stack != top_node) //Check if the required node is not already the first node
	{
		if (stack_name == 'a') //If not, and it is stack `a`, execute the following
		{
			if (top_node->above_median_line)
				ra(stack, 0);
			else
				rra(stack, 0);
		}
		else if (stack_name == 'b') //If not, and it is stack `b`, execute the following
		{
			if (top_node->above_median_line)
				rb(stack, 0);
			else
				rrb(stack, 0);
		}	
	}
}

 void	move_a_2_b(t_stack_node **a, t_stack_node **b) //Define a function that prepares the cheapest nodes on top of the stacks for pushing `a` nodes to stack `b`, until there are three nodes left in `a`
{
	t_stack_node	*cheapest_node; //To store the pointer to the cheapest `a` node

	cheapest_node = get_cheapest(*a); 
	if (cheapest_node->above_median_line 
		&& cheapest_node->target_node->above_median_line) //If both the cheapest `a` node and its target `b` node are above the median
		rotate_a_n_b(a, b, cheapest_node);
	else if (!(cheapest_node->above_median_line) 
		&& !(cheapest_node->target_node->above_median_line)) //If both the cheapest `a` node and its target `b` node are below the median
		rev_rotate_a_n_b(a, b, cheapest_node); //`rev_rotate_both` will execute if neither nodes are at the top
	prep_for_push(a, cheapest_node, 'a'); //Ensure the cheapest nodes is at the top, ready for pushing
	prep_for_push(b, cheapest_node->target_node, 'b'); //Ensure the target node is at the top, ready for pushing
	pb(b, a, 0);
}

void	move_b_2_a(t_stack_node **a, t_stack_node **b)
{
	prep_for_push(a, (*b)->target_node, 'a'); //Ensure `b`'s target `a` node is on top of the stack
	pa(a, b, 0); 
}


void	turk_sort(t_stack_node **a, t_stack_node **b)
{
	int	len;

	len = len_stack(*a);
	if (len-- > 3 && !stack_sorted(*a))
		pb(b, a, 0);
	if (len-- > 3 && !stack_sorted(*a))
		pb(b, a, 0);
	while (len-- > 3 && !stack_sorted(*a))
	{
		init_node_a(*a, *b);
		move_a_2_b(a, b);
	}
	sort_three(a);
	while (*b)
	{
		init_nodes_b(*a, *b);
		move_b_2_a(a, b);
	}
	current_index(*a);
	min_on_top(a);
}
NAME                = push_swap

INC                 = .
SRC_DIR             = .
HEADER              = push_swap.h
OBJ_DIR             = obj/

CC                  = cc
CFLAGS              = -Wall -Werror -Wextra -I$(INC) -MMD
RM                  = rm -rf

MOVES_DIR           =   $(SRC_DIR)/moves/pushing.c \
                        $(SRC_DIR)/moves/rotating.c \
                        $(SRC_DIR)/moves/rrotating.c \
                        $(SRC_DIR)/moves/swaping.c

PARSING_DIR         =   $(SRC_DIR)/parsing/libft_tools.c \
                        $(SRC_DIR)/parsing/split.c \
                        $(SRC_DIR)/parsing/validating.c

TOOLS_DIR           =   $(SRC_DIR)/tools/initialiase_a_2_b.c \
                        $(SRC_DIR)/tools/initialiase_b_2_a.c \
                        $(SRC_DIR)/tools/stack_helpers.c \
                        $(SRC_DIR)/tools/stack_helpers2.c

TURKALGO_DIR        =   $(SRC_DIR)/turkalgo/three_sort.c \
                        $(SRC_DIR)/turkalgo/turk_sort.c

MAIN_DIR            =   $(SRC_DIR)/push_swap.c

SRCS                = $(MOVES_DIR) $(PARSING_DIR) $(TOOLS_DIR) $(TURKALGO_DIR) $(MAIN_DIR)
OBJS                = $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SRCS))
DEPS                = $(OBJS:.o=.d)

all:                $(NAME)

$(NAME):            $(OBJS) $(HEADER)
					$(CC) $(CFLAGS) $(OBJS) -o $(NAME)

$(OBJ_DIR)/%.o:     $(SRC_DIR)/%.c
					@mkdir -p $(@D)
					$(CC) $(CFLAGS) -c $< -o $@

clean:
					$(RM) $(OBJ_DIR)

fclean:             clean
					$(RM) $(NAME)

re:                 fclean all

-include $(DEPS)

.PHONY:             all clean fclean re/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 15:24:22 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/21 19:38:53 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	main(int ac, char **av)
{
	t_stack_node	*a;
	t_stack_node	*b;

	a = NULL;
	b = NULL;
	if (ac == 1 || (ac == 2 && !av[1][0]))
		return (1);
	else if (ac == 2)
		av = split(av[1], ' ');
	init_stack_a(&a, av + 1);
	if (!stack_sorted(a))
	{
		if (stack_length(a) == 2)
			sa(&a, 0);
		else if (stack_length(a) == 3)
			sort_three(&a);
		else
			turk_sort(&a, &b);
	}
	free_stack(&a);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 21:52:41 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 19:11:16 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PUSH_SWAP_H
# define PUSH_SWAP_H
# include <unistd.h>
# include <limits.h>
# include <stdlib.h>
//Must delete this
# include <stdio.h>
// # include <fcntl.h>

typedef struct s_stack_node
{
	int						indexing;
	int						value;
	int						push_cost;
	int						above_median_line;
	int						cheapest;
	struct s_stack_node		*previous;
	struct s_stack_node		*next;
	struct s_stack_node		*target_node;
}	t_stack_node;

//libft_tools.c

int				ft_strlen(const char *s);
int				stack_length(t_stack_node *stack);
t_stack_node	*last_node(t_stack_node *stack);
//t_stack_node	*ft_lstnew(void *content);

// split.c file
int				ft_isdigit(int c);
char			**split(char *s, char c)
;void			free_error(t_stack_node **a);
void			free_stack(t_stack_node **stack);
long	ft_atol(const char *s);
//---
// validating.c

int				syntax_error(char *str_n);
int				error_duplicate(t_stack_node *a, int n);
// moves foldder

void			push(t_stack_node **dst, t_stack_node **src);
void			pa(t_stack_node **a, t_stack_node **b, int testing);
void			pb(t_stack_node **a, t_stack_node **b, int testing);
void			ft_rotate_node(t_stack_node **stack);
void			ra(t_stack_node **a, int testing);
void			rb(t_stack_node **b, int testing);
void			rr(t_stack_node **a, t_stack_node **b, int testing);
void ft_rev_rotate_node(t_stack_node **stack);
void			rra(t_stack_node **a, int testing);
void			rrb(t_stack_node **b, int testing);
void			rrr(t_stack_node **a, t_stack_node **b, int testing);
void			ft_swap_node(t_stack_node **head);
void			sa(t_stack_node **a, int testing);
void			sb(t_stack_node **b, int testing);
void			ss(t_stack_node **a, t_stack_node **b, int testing);

// initialiase_a_2_b.c

void			set_cheapest_node(t_stack_node *stack);
void			cost_analysis_a(t_stack_node *a, t_stack_node *b);
void			set_target_a(t_stack_node *a, t_stack_node *b);
void			current_index(t_stack_node *stack);
void	init_node_a(t_stack_node *a, t_stack_node *b);
t_stack_node	*get_cheapest(t_stack_node *stack);
// initialiase_b_2_a.c
void			init_nodes_b(t_stack_node *a, t_stack_node *b);
void			set_target_b(t_stack_node *a, t_stack_node *b);

// stackhelper.c
void			ft_putstr(char *str);
int				len_stack(t_stack_node *stack);
int				stack_sorted(t_stack_node *stack);
t_stack_node	*find_min_node(t_stack_node *stack);
t_stack_node	*find_max_node(t_stack_node *stack);

// stackhelper2.c

void			append_node(t_stack_node **stack, int n);
void			init_stack_a(t_stack_node **a, char **av);
void			set_cheapest_node(t_stack_node *stack);

//turk algo

void			min_on_top(t_stack_node **a);
void			sort_three(t_stack_node **a);
void			rotate_a_n_b(t_stack_node **a, t_stack_node **b,
					t_stack_node *cheapest_node);
void			rev_rotate_a_n_b(t_stack_node **a, t_stack_node **b,
					t_stack_node *cheapest_node);
void			turk_sort(t_stack_node **a, t_stack_node **b);
void			move_a_2_b(t_stack_node **a, t_stack_node **b);
void			move_b_2_a(t_stack_node **a, t_stack_node **b);
void	prep_for_push(t_stack_node **stack,t_stack_node *top_node,char stack_name);

#endif