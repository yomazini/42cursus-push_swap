NAME = push_swap

CC = cc
CFLAGS = -Wall -Werror -Wextra
RM = rm -rf

OBJ_DIR = obj
HEADER = push_swap.h

OBJS = \
	$(OBJ_DIR)/moves/pushing.o \
	$(OBJ_DIR)/moves/rotating.o \
	$(OBJ_DIR)/moves/rrotating.o \
	$(OBJ_DIR)/moves/swaping.o \
	$(OBJ_DIR)/parsing/libft_tools.o \
	$(OBJ_DIR)/parsing/libft_tools1.o \
	$(OBJ_DIR)/parsing/split.o \
	$(OBJ_DIR)/parsing/validating.o \
	$(OBJ_DIR)/parsing/validating2.o \
	$(OBJ_DIR)/tools/initialiase_a_2_b.o \
	$(OBJ_DIR)/tools/initialiase_b_2_a.o \
	$(OBJ_DIR)/tools/stack_helpers.o \
	$(OBJ_DIR)/tools/stack_helpers2.o \
	$(OBJ_DIR)/turkalgo/three_sort.o \
	$(OBJ_DIR)/turkalgo/turk_sort.o \
	$(OBJ_DIR)/push_swap.o

BONUS_OBJS = \
	$(OBJ_DIR)/checker/checker.o \
	$(OBJ_DIR)/checker/execute_commands.o \
	$(OBJ_DIR)/checker/get_next_line.o \
	$(OBJ_DIR)/checker/get_next_line_utils.o

all: $(NAME)

$(NAME): $(OBJS)
	$(CC) $(CFLAGS) $^ -o $@

$(OBJ_DIR)/%.o: %.c $(HEADER)
	mkdir -p $(@D)
	$(CC) $(CFLAGS) -c $< -o $@


bonus: $(BONUS_OBJS) $(OBJS)
	$(CC) $(CFLAGS) $^ -o checker

clean:
	$(RM) $(OBJ_DIR)

fclean: clean
	$(RM) $(NAME)

re: fclean all
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 15:24:22 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 15:04:45 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	main(int ac, char **av)
{
	t_stack_node	*a;
	t_stack_node	*b;
	char			**split_av;

	a = NULL;
	b = NULL;
	if (ac == 1)
		return (1);
	split_av = split_args(ac, av);
	if (!split_av || !*split_av)
		return (free_strs(split_av), ft_putstr("Error\n"), 1);
	init_stack_a(&a, split_av, split_av);
	free_strs(split_av);
	if (!stack_sorted(a))
	{
		if (stack_length(a) == 2)
			sa(&a, 0);
		else if (stack_length(a) == 3)
			sort_three(&a);
		else
			turk_sort(&a, &b);
	}
	free_stack(&a);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 21:52:41 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 15:48:39 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PUSH_SWAP_H
# define PUSH_SWAP_H
# include <unistd.h>
# include <limits.h>
# include <stdlib.h>

typedef struct s_stack_node
{
	int						indexing;
	int						value;
	int						push_cost;
	int						above_median_line;
	int						cheapest;
	struct s_stack_node		*previous;
	struct s_stack_node		*next;
	struct s_stack_node		*target_node;
}	t_stack_node;

int				ft_strlen(const char *s);
int				stack_length(t_stack_node *stack);
t_stack_node	*last_node(t_stack_node *stack);
int				ft_isdigit(int c);
char			**split(char *s, char c);
void			free_error(t_stack_node **a, char **split_av);
void			free_stack(t_stack_node **stack);
long			ft_atol(const char *s);
int				syntax_error(char *s);
int				error_duplicate(t_stack_node *a, int n);
void			push(t_stack_node **dst, t_stack_node **src);
void			pa(t_stack_node **a, t_stack_node **b, int testing);
void			pb(t_stack_node **a, t_stack_node **b, int testing);
void			ft_rotate_node(t_stack_node **stack);
void			ra(t_stack_node **a, int testing);
void			rb(t_stack_node **b, int testing);
void			rr(t_stack_node **a, t_stack_node **b, int testing);
void			ft_rev_rotate_node(t_stack_node **stack);
void			rra(t_stack_node **a, int testing);
void			rrb(t_stack_node **b, int testing);
void			rrr(t_stack_node **a, t_stack_node **b, int testing);
void			ft_swap_node(t_stack_node **head);
void			sa(t_stack_node **a, int testing);
void			sb(t_stack_node **b, int testing);
void			ss(t_stack_node **a, t_stack_node **b, int testing);
void			set_cheapest_node(t_stack_node *stack);
void			cost_analysis_a(t_stack_node *a, t_stack_node *b);
void			set_target_a(t_stack_node *a, t_stack_node *b);
void			current_index(t_stack_node *stack);
void			init_node_a(t_stack_node *a, t_stack_node *b);
t_stack_node	*get_cheapest(t_stack_node *stack);
void			init_nodes_b(t_stack_node *a, t_stack_node *b);
void			set_target_b(t_stack_node *a, t_stack_node *b);
void			ft_putstr(char *str);
int				len_stack(t_stack_node *stack);
int				stack_sorted(t_stack_node *stack);
t_stack_node	*find_min_node(t_stack_node *stack);
t_stack_node	*find_max_node(t_stack_node *stack);
void			append_node(t_stack_node **stack, int n);
void			init_stack_a(t_stack_node **a, char **av, char **split_av);
void			set_cheapest_node(t_stack_node *stack);
void			min_on_top(t_stack_node **a);
void			sort_three(t_stack_node **a);
void			rotate_a_n_b(t_stack_node **a, t_stack_node **b,
					t_stack_node *cheapest_node);
void			rev_rotate_a_n_b(t_stack_node **a, t_stack_node **b,
					t_stack_node *cheapest_node);
void			turk_sort(t_stack_node **a, t_stack_node **b);
void			move_a_2_b(t_stack_node **a, t_stack_node **b);
void			prep_for_push(t_stack_node **stack, t_stack_node *top_node,
					char stack_name);
void			move_b_2_a(t_stack_node **a, t_stack_node **b);
char			**split_args(int ac, char **av);
int				ft_strslen(char **strs);
size_t			ft_strlcpy(char *dst, const char *src, size_t dstsize);
void			free_strs(char **strs);
char			*ft_strdup(const char *src);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checker.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:36:05 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 20:43:57 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"

static void	clean_and_exit(t_stack_node **a, t_stack_node **b, int status)
{
	free_stack(a);
	free_stack(b);
	if (status == 1)
		ft_putstr("Error\n");
	exit(status);
}

static void	check_result(t_stack_node *a, t_stack_node *b)
{
	if (stack_sorted(a) && !b)
		ft_putstr("OK\n");
	else
		ft_putstr("KO\n");
}

int	main(int ac, char **av)
{
	t_stack_node	*a;
	t_stack_node	*b;
	char			**split_av;

	a = NULL;
	b = NULL;
	if (ac == 1)
		return (0);
	split_av = split_args(ac - 1, av + 1);
	if (!split_av || !*split_av)
		clean_and_exit(&a, &b, 1);
	init_stack_a(&a, split_av, split_av);
	free_strs(split_av);
	execute_commands(&a, &b);
	check_result(a, b);
	clean_and_exit(&a, &b, 0);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checker.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:38:41 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 20:52:21 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CHECKER_H
# define CHECKER_H
# include "../push_swap.h"

# define BUFFER_SIZE 42

// Checker main
void	checker(t_stack_node **a, t_stack_node **b);

// Command execution
void	execute_commands(t_stack_node **a, t_stack_node **b);
int		execute(char *cmd, t_stack_node **a, t_stack_node **b);

int	ft_strncmp(const char *s1, const char *s2, size_t n);
int	ft_strcmp(char *s1, char *s2);

// GNL
char	*get_next_line(int fd);
char	*gnl_strjoin(char *s1, char *s2);
int		gnl_strchr(char *s, char c);
size_t	gnl_strlen(char *s);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_commands.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 20:42:47 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 20:47:57 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"

int	ft_strcmp(char *s1, char *s2)
{
	unsigned int	i;

	i = 0;
	while (s2[i] && s1[i] && (s1[i] == s2[i]))
	{
		i++;
	}
	return (s1[i] - s2[i]);
}

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (s1[i] && s2[i] && s1[i] == s2[i] && i < n - 1)
	{
		i++;
	}
	return ((unsigned char)s1[i] -(unsigned char)s2[i]);
}

static int	is_valid(char *cmd)
{
	const char	*cmds[] = {"pa\n", "pb\n", "sa\n", "sb\n", "ss\n",
		"ra\n", "rb\n", "rr\n", "rra\n", "rrb\n", "rrr\n", NULL};
	int			i;

	i = -1;
	while (cmds[++i])
		if (!ft_strncmp(cmd, cmds[i], ft_strlen(cmds[i])))
			return (1);
	return (0);
}

int	execute(char *cmd, t_stack_node **a, t_stack_node **b)
{
	if (!ft_strcmp(cmd, "pa\n")) return (pa(a, b, 1), 1);
	if (!ft_strcmp(cmd, "pb\n")) return (pb(b, a, 1), 1);
	if (!ft_strcmp(cmd, "sa\n")) return (sa(a, 1), 1);
	if (!ft_strcmp(cmd, "sb\n")) return (sb(b, 1), 1);
	if (!ft_strcmp(cmd, "ss\n")) return (ss(a, b, 1), 1);
	if (!ft_strcmp(cmd, "ra\n")) return (ra(a, 1), 1);
	if (!ft_strcmp(cmd, "rb\n")) return (rb(b, 1), 1);
	if (!ft_strcmp(cmd, "rr\n")) return (rr(a, b, 1), 1);
	if (!ft_strcmp(cmd, "rra\n")) return (rra(a, 1), 1);
	if (!ft_strcmp(cmd, "rrb\n")) return (rrb(b, 1), 1);
	if (!ft_strcmp(cmd, "rrr\n")) return (rrr(a, b, 1), 1);
	return (0);
}

static void	clean_and_exit(t_stack_node **a, t_stack_node **b, int status)
{
	free_stack(a);
	free_stack(b);
	if (status == 1)
		ft_putstr("Error\n");
	exit(status);
}

void	execute_commands(t_stack_node **a, t_stack_node **b)
{
	char	*cmd;

	cmd = get_next_line(0);
	while (cmd)
	{
		if (!is_valid(cmd) || !execute(cmd, a, b))
		{
			free(cmd);
			clean_and_exit(a, b, 1);
		}
		free(cmd);
		cmd = get_next_line(0);
	}
	free(cmd);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:36:07 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 20:41:16 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"

#include "checker.h"

char	*get_next_line(int fd)
{
	static char	*buf;
	char		*line;
	int			read_size;
	char		temp[BUFFER_SIZE + 1];

	if (fd < 0 || BUFFER_SIZE < 1)
		return (NULL);
	while (!gnl_strchr(buf, '\n'))
	{
		read_size = read(fd, temp, BUFFER_SIZE);
		if (read_size < 0)
			return (free(buf), buf = NULL, NULL);
		if (read_size == 0)
			break ;
		temp[read_size] = 0;
		buf = gnl_strjoin(buf, temp);
	}
	if (!buf)
		return (NULL);
	line = gnl_strjoin(NULL, buf);
	if (gnl_strchr(buf, '\n'))
		buf = gnl_strjoin(buf + gnl_strlen(line), NULL);
	else
		free(buf), buf = NULL;
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:36:10 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 20:41:03 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"
#include "checker.h"

size_t	gnl_strlen(char *s)
{
	size_t	i;

	i = 0;
	while (s && s[i])
		i++;
	return (i);
}

int	gnl_strchr(char *s, char c)
{
	int	i;

	i = -1;
	while (s && s[++i])
		if (s[i] == c)
			return (1);
	return (0);
}

char	*gnl_strjoin(char *s1, char *s2)
{
	char	*new;
	int		i;
	int		j;

	new = malloc(gnl_strlen(s1) + gnl_strlen(s2) + 1);
	if (!new)
		return (free(s1), NULL);
	i = 0;
	j = 0;
	while (s1 && s1[j])
		new[i++] = s1[j++];
	j = 0;
	while (s2 && s2[j])
		new[i++] = s2[j++];
	new[i] = 0;
	free(s1);
	return (new);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pushing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:09:54 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 22:32:34 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	push(t_stack_node **dst, t_stack_node **src)
{
	t_stack_node	*push_node;

	if (!*src)
		return ;
	push_node = *src;
	*src = (*src)->next;
	if (*src)
		(*src)->previous = NULL;
	push_node->previous = NULL;
	if (!*dst)
	{
		*dst = push_node;
		push_node->next = NULL;
	}
	else
	{
		push_node->next = *dst;
		push_node->next->previous = push_node;
		*dst = push_node;
	}
}

void	pa(t_stack_node **a, t_stack_node **b, int testing)
{
	push(a, b);
	if (!testing)
		ft_putstr("pa\n");
}

void	pb(t_stack_node **b, t_stack_node **a, int testing)
{
	push(b, a);
	if (!testing)
		ft_putstr("pb\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rotating.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:58:24 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 22:32:54 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	ft_rotate_node(t_stack_node **stack)
{
	t_stack_node	*last_node1;

	if (!*stack || !(*stack)->next)
		return ;
	last_node1 = last_node(*stack);
	last_node1->next = *stack;
	*stack = (*stack)->next;
	(*stack)->previous = NULL;
	last_node1->next->previous = last_node1;
	last_node1->next->next = NULL;
}

void	ra(t_stack_node **a, int testing)
{
	ft_rotate_node(a);
	if (!testing)
		ft_putstr("ra\n");
}

void	rb(t_stack_node **b, int testing)
{
	ft_rotate_node(b);
	if (!testing)
		ft_putstr("rb\n");
}

void	rr(t_stack_node **a, t_stack_node **b, int testing)
{
	ft_rotate_node(a);
	ft_rotate_node(b);
	if (!testing)
		ft_putstr("rr\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rrotating.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:02:59 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 22:33:44 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	ft_rev_rotate_node(t_stack_node **stack)
{
	t_stack_node	*last;

	if (!*stack || !(*stack)->next)
		return ;
	last = last_node(*stack);
	last->previous->next = NULL;
	last->next = *stack;
	last->previous = NULL;
	*stack = last;
	last->next->previous = last;
}

void	rra(t_stack_node **a, int testing)
{
	ft_rev_rotate_node(a);
	if (!testing)
		ft_putstr("rra\n");
}

void	rrb(t_stack_node **b, int testing)
{
	ft_rev_rotate_node(b);
	if (!testing)
		ft_putstr("rrb\n");
}

void	rrr(t_stack_node **a, t_stack_node **b, int testing)
{
	ft_rev_rotate_node(a);
	ft_rev_rotate_node(b);
	if (!testing)
		ft_putstr("rrr\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   swaping.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:09:00 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 19:40:47 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

// void	ft_swap_node(t_stack_node **head)
// {
// 	if (!*head || !(*head)->next)
// 		return ;
// 	*head = (*head)->next;
// 	(*head)->previous->previous = *head;
// 	(*head)->previous->next = (*head)->next;
// 	if ((*head)->next)
// 		(*head)->next->previous = (*head)->previous;
// 	(*head)->next = (*head)->previous;
// 	(*head)->previous = NULL;
// }

void	ft_swap_node(t_stack_node **head)
{
	t_stack_node	*first;
	t_stack_node	*second;

	if (!*head || !(*head)->next)
		return ;
	first = *head;
	second = first->next;
	first->next = second->next;
	if (second->next)
		second->next->previous = first;
	second->previous = first->previous;
	first->previous = second;
	second->next = first;
	*head = second;
}

void	sa(t_stack_node	**a, int testing)
{
	ft_swap_node(a);
	if (!testing)
		ft_putstr("sa\n");
}

void	sb(t_stack_node **b, int testing)
{
	ft_swap_node(b);
	if (!testing)
		ft_putstr("sb\n");
}

void	ss(t_stack_node **a, t_stack_node **b, int testing)
{
	ft_swap_node(a);
	ft_swap_node(b);
	if (!testing)
		ft_putstr("ss\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft_tools.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 15:31:13 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 19:17:51 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

int	ft_strlen(const char *s)
{
	size_t	i;

	i = 0;
	while (s[i])
		i++;
	return (i);
}

int	stack_length(t_stack_node *stack)
{
	int	i;

	i = 0;
	if (!stack)
		return (0);
	while (stack)
	{
		i++;
		stack = stack->next;
	}
	return (i);
}

t_stack_node	*last_node(t_stack_node *stack)
{
	if (!stack)
		return (NULL);
	while (stack->next)
		stack = stack->next;
	return (stack);
}

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	return (0);
}

long	ft_atol(const char *s)
{
	long	result;
	int		sign;

	result = 0;
	sign = 1;
	while (*s == ' ' || (*s >= '\t' && *s <= '\r'))
		s++;
	if (*s == '-' || *s == '+')
	{
		if (*s == '-')
			sign = -1;
		s++;
	}
	while (ft_isdigit(*s))
		result = result * 10 + (*s++ - '0');
	return (result * sign);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft_tools1.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 15:40:48 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 15:41:57 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

size_t	ft_strlcpy(char *dst, const char *src, size_t dstsize)
{
	size_t	slen;
	size_t	i;

	slen = ft_strlen(src);
	i = 0;
	if (dstsize == 0)
		return (slen);
	while (src[i] && i < dstsize - 1)
	{
		dst[i] = src[i];
		i++;
	}
	dst[i] = '\0';
	return (slen);
}

void	*ft_memcpy(void *dst, const void *src, size_t n)
{
	size_t				i;
	unsigned char		*ptr;
	const unsigned char	*s;

	i = 0;
	if (!dst && !src)
		return (NULL);
	if (dst == src)
		return (dst);
	ptr = (unsigned char *)dst;
	s = (const unsigned char *)src;
	while (i < n)
	{
		ptr[i] = s[i];
		i++;
	}
	return (dst);
}

char	*ft_strdup(const char *src)
{
	size_t	size;
	char	*str;

	size = ft_strlen(src);
	str = malloc (size + 1);
	if (!str)
		return (NULL);
	ft_memcpy(str, src, size);
	str [size] = '\0';
	return (str);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   split.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 15:32:26 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 15:28:50 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

static int	count_words(char *s, char c)
{
	int	count;
	int	in_word;

	count = 0;
	in_word = 0;
	while (*s)
	{
		if (*s != c && !in_word)
		{
			in_word = 1;
			count++;
		}
		else if (*s == c)
			in_word = 0;
		s++;
	}
	return (count);
}

static char	*extract_word(char *s, char c, int *index)
{
	int		start;
	int		end;
	char	*word;

	while (s[*index] == c)
		(*index)++;
	start = *index;
	while (s[*index] && s[*index] != c)
		(*index)++;
	end = *index;
	if (start == end)
		return (NULL);
	word = malloc(end - start + 1);
	if (!word)
		return (NULL);
	ft_strlcpy(word, &s[start], end - start + 1);
	return (word);
}

static void	init_vars_4_split(int *i, int *j)
{
	*i = 0;
	*j = -1;
}

char	**split(char *s, char c)
{
	int		word_count;
	char	**result;
	int		i;
	int		j;

	if (!s || !*s)
		return (NULL);
	word_count = count_words(s, c);
	init_vars_4_split(&i, &j);
	if (!word_count)
		return (NULL);
	result = malloc(sizeof(char *) * (word_count + 1));
	if (!result)
		return (NULL);
	while (++j < word_count)
	{
		result[j] = extract_word(s, c, &i);
		if (!result[j])
		{
			while (j-- > 0)
				free(result[j]);
			return (free(result), NULL);
		}
	}
	return (result[j] = NULL, result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validating.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 16:19:21 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 15:53:40 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

int	syntax_error(char *s)
{
	int	len;

	len = 0;
	if (!(*s == '+' || *s == '-' || (*s >= '0' && *s <= '9')))
		return (1);
	if ((*s == '+' || *s == '-') && !(s[1] >= '0' && s[1] <= '9'))
		return (1);
	if (*s == '+' || *s == '-')
		s++;
	while (*s)
	{
		if (!(*s >= '0' && *s <= '9'))
			return (1);
		len++;
		s++;
	}
	if (len > 18)
		return (1);
	return (0);
}

int	error_duplicate(t_stack_node *a, int n)
{
	if (!a)
		return (0);
	while (a)
	{
		if (a->value == n)
			return (1);
		a = a->next;
	}
	return (0);
}

void	free_stack(t_stack_node **stack)
{
	t_stack_node	*tmp;
	t_stack_node	*current;

	if (!stack)
		return ;
	current = *stack;
	while (current)
	{
		tmp = current->next;
		current->value = 0;
		free(current);
		current = tmp;
	}
	*stack = NULL;
}

void	free_error(t_stack_node **a, char **split_av)
{
	free_stack(a);
	free_strs(split_av);
	ft_putstr("Error\n");
	exit(1);
}

t_stack_node	*get_cheapest(t_stack_node *stack)
{
	if (!stack)
		return (NULL);
	while (stack)
	{
		if (stack->cheapest)
			return (stack);
		stack = stack->next;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validating2.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 15:30:46 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 19:20:28 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	free_strs(char **strs)
{
	int	i;

	if (!strs)
		return ;
	i = 0;
	while (strs[i])
		free(strs[i++]);
	free(strs);
}

int	ft_strslen(char **strs)
{
	int	i;

	i = 0;
	while (strs[i])
		i++;
	return (i);
}

static int	count_total_words(int ac, char **av)
{
	int		total;
	int		i;
	char	**temp;

	total = 0;
	i = 1;
	while (i < ac)
	{
		temp = split(av[i], ' ');
		if (!temp)
			return (-1);
		total += ft_strslen(temp);
		free_strs(temp);
		i++;
	}
	return (total);
}

static int	copy_temp(char **result, char **temp, int k)
{
	int	j;

	j = 0;
	while (temp[j])
	{
		result[k] = ft_strdup(temp[j]);
		if (!result[k])
		{
			free_strs(temp);
			free_strs(result);
			return (-1);
		}
		k++;
		j++;
	}
	return (k);
}

char	**split_args(int ac, char **av)
{
	char	**result;
	char	**temp;
	int		i;
	int		k;
	int		total_words;

	total_words = count_total_words(ac, av);
	if (total_words <= 0)
		return (NULL);
	result = malloc(sizeof(char *) * (total_words + 1));
	if (!result)
		return (NULL);
	k = 0;
	i = 0;
	while (++i < ac)
	{
		temp = split(av[i], ' ');
		if (!temp)
			return (free_strs(result), NULL);
		k = copy_temp(result, temp, k);
		free_strs(temp);
		if (k == -1)
			return (NULL);
	}
	return (result[k] = NULL, result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialiase_a_2_b.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:21:38 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/30 13:29:52 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	current_index(t_stack_node *stack)
{
	int	i;
	int	median;

	i = 0;
	if (!stack)
		return ;
	median = len_stack(stack) / 2;
	while (stack)
	{
		stack->indexing = i;
		if (i <= median)
			stack->above_median_line = 1;
		else
			stack->above_median_line = 0;
		stack = stack->next;
		i++;
	}
}

void	set_target_a(t_stack_node *a, t_stack_node *b)
{
	t_stack_node	*current_b;
	t_stack_node	*target_node;
	long			best_match_index;

	while (a)
	{
		best_match_index = LONG_MIN;
		current_b = b;
		while (current_b)
		{
			if (current_b->value < a->value
				&& current_b->value > best_match_index)
			{
				best_match_index = current_b->value;
				target_node = current_b;
			}
			current_b = current_b->next;
		}
		if (best_match_index == LONG_MIN)
			a->target_node = find_max_node(b);
		else
			a->target_node = target_node;
		a = a->next;
	}
}

void	cost_analysis_a(t_stack_node *a, t_stack_node *b)
{
	int	len_a;
	int	len_b;

	len_a = len_stack(a);
	len_b = len_stack(b);
	while (a)
	{
		a->push_cost = a->indexing;
		if (!(a->above_median_line))
			a->push_cost = len_a - (a->indexing);
		if (a->target_node->above_median_line)
			a->push_cost += a->target_node->indexing;
		else
			a->push_cost += len_b - (a->target_node->indexing);
		a = a->next;
	}
}

void	init_node_a(t_stack_node *a, t_stack_node *b)
{
	current_index(a);
	current_index(b);
	set_target_a(a, b);
	cost_analysis_a(a, b);
	set_cheapest_node(a);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialiase_b_2_a.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:29:46 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 22:12:56 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	set_target_b(t_stack_node *a, t_stack_node *b)
{
	t_stack_node	*current_a;
	t_stack_node	*target_node;
	long			best_match_index;

	while (b)
	{
		best_match_index = LONG_MAX;
		current_a = a;
		while (current_a)
		{
			if (current_a->value > b->value
				&& current_a->value < best_match_index)
			{
				best_match_index = current_a->value;
				target_node = current_a;
			}
			current_a = current_a->next;
		}
		if (best_match_index == LONG_MAX)
			b->target_node = find_min_node(a);
		else
			b->target_node = target_node;
		b = b->next;
	}
}

void	init_nodes_b(t_stack_node *a, t_stack_node *b)
{
	current_index(a);
	current_index(b);
	set_target_b(a, b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_helpers.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:32:04 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 22:13:53 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	ft_putstr(char *str)
{
	while (*str)
	{
		write(1, str, 1);
		str++;
	}
}

int	len_stack(t_stack_node *stack)
{
	int	i;

	i = 0;
	if (!stack)
		return (0);
	while (stack)
	{
		i++;
		stack = stack->next;
	}
	return (i);
}

int	stack_sorted(t_stack_node *stack)
{
	if (!stack)
		return (1);
	while (stack->next)
	{
		if (stack->value > stack->next->value)
			return (0);
		stack = stack->next;
	}
	return (1);
}

t_stack_node	*find_min_node(t_stack_node *stack)
{
	t_stack_node	*min_node;
	long			min_number;

	min_number = LONG_MAX;
	if (!stack)
		return (NULL);
	while (stack)
	{
		if (stack->value < min_number)
		{
			min_number = stack->value;
			min_node = stack;
		}
		stack = stack->next;
	}
	return (min_node);
}

t_stack_node	*find_max_node(t_stack_node *stack)
{
	t_stack_node	*max_node;
	long			max_number;

	max_number = LONG_MIN ;
	if (!stack)
		return (NULL);
	while (stack)
	{
		if (max_number < stack->value)
		{
			max_number = stack->value;
			max_node = stack;
		}
		stack = stack->next;
	}
	return (max_node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_helpers2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 17:36:00 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 19:41:20 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	append_node(t_stack_node **stack, int n)
{
	t_stack_node	*node;
	t_stack_node	*last_node1;

	if (!stack)
		return ;
	node = malloc(sizeof(t_stack_node));
	if (!node)
		free_error(stack, NULL);
	node->next = NULL;
	node->value = n;
	node->cheapest = 0;
	if (!(*stack))
	{
		*stack = node;
		node->previous = NULL;
	}
	else
	{
		last_node1 = last_node(*stack);
		last_node1->next = node;
		node->previous = last_node1;
	}
}

void	init_stack_a(t_stack_node **a, char **av, char **split_av)
{
	long	nmr;
	int		number;
	int		i;

	i = 0;
	while (av[i])
	{
		if (syntax_error(av[i]))
			free_error(a, split_av);
		nmr = ft_atol(av[i]);
		if (nmr < INT_MIN || nmr > INT_MAX)
			free_error(a, split_av);
		number = (int)nmr;
		if (error_duplicate(*a, number))
			free_error(a, split_av);
		append_node(a, number);
		i++;
	}
}

void	set_cheapest_node(t_stack_node *stack)
{
	long			cheapest_value;
	t_stack_node	*cheapest_node;

	if (!stack)
		return ;
	cheapest_value = LONG_MAX;
	while (stack)
	{
		if (stack->push_cost < cheapest_value)
		{
			cheapest_value = stack->push_cost;
			cheapest_node = stack;
		}
		stack = stack->next;
	}
	cheapest_node->cheapest = 1;
}

void	rotate_a_n_b(t_stack_node **a,
						t_stack_node **b,
						t_stack_node *cheapest_node)
{
	while (*b != cheapest_node->target_node
		&& *a != cheapest_node)
		rr(a, b, 0);
	current_index(*a);
	current_index(*b);
}

void	rev_rotate_a_n_b(t_stack_node **a,
						t_stack_node **b,
						t_stack_node *cheapest_node)
{
	while (*b != cheapest_node->target_node
		&& *a != cheapest_node)
		rrr(a, b, 0);
	current_index(*a);
	current_index(*b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   three_sort.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:18:08 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/29 21:59:31 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	min_on_top(t_stack_node **a)
{
	while ((*a)->value != find_min_node(*a)->value)
	{
		if (find_min_node(*a)->above_median_line)
			ra(a, 0);
		else
			rra(a, 0);
	}
}

void	sort_three(t_stack_node **a)
{
	t_stack_node	*biggest_node;

	biggest_node = find_max_node(*a);
	if (biggest_node == *a)
		ra(a, 0);
	else if ((*a)->next == biggest_node)
		rra(a, 0);
	if ((*a)->value > (*a)->next->value)
		sa(a, 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   turk_sort.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 18:20:41 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/30 17:01:04 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	prep_for_push(t_stack_node **stack,
						t_stack_node *top_node,
						char stack_name)
{
	while (*stack != top_node)
	{
		if (stack_name == 'a')
		{
			if (top_node->above_median_line)
				ra(stack, 0);
			else
				rra(stack, 0);
		}
		else if (stack_name == 'b')
		{
			if (top_node->above_median_line)
				rb(stack, 0);
			else
				rrb(stack, 0);
		}
	}
}

void	move_a_2_b(t_stack_node **a, t_stack_node **b)
{
	t_stack_node	*cheapest_node;

	cheapest_node = get_cheapest(*a);
	if (cheapest_node->above_median_line
		&& cheapest_node->target_node->above_median_line)
		rotate_a_n_b(a, b, cheapest_node);
	else if (!(cheapest_node->above_median_line)
		&& !(cheapest_node->target_node->above_median_line))
		rev_rotate_a_n_b(a, b, cheapest_node);
	prep_for_push(a, cheapest_node, 'a');
	prep_for_push(b, cheapest_node->target_node, 'b');
	pb(b, a, 0);
}

void	move_b_2_a(t_stack_node **a, t_stack_node **b)
{
	prep_for_push(a, (*b)->target_node, 'a');
	pa(a, b, 0);
}

void	turk_sort(t_stack_node **a, t_stack_node **b)
{
	int	len;

	len = len_stack(*a);
	if (len-- > 3 && !stack_sorted(*a))
		pb(b, a, 0);
	if (len-- > 3 && !stack_sorted(*a))
		pb(b, a, 0);
	while (len-- > 3 && !stack_sorted(*a))
	{
		init_node_a(*a, *b);
		move_a_2_b(a, b);
	}
	sort_three(a);
	while (*b)
	{
		init_nodes_b(*a, *b);
		move_b_2_a(a, b);
	}
	current_index(*a);
	min_on_top(a);
}
