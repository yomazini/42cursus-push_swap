/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checker.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:36:05 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 21:18:14 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"

static void	clean_and_exit(t_stack_node **a, t_stack_node **b, int status)
{
	free_stack(a);
	free_stack(b);
	if (status == 1)
		ft_putstr("Error\n");
	exit(status);
}

static void	check_result(t_stack_node *a, t_stack_node *b)
{
	if (stack_sorted(a) && !b)
		ft_putstr("OK\n");
	else
		ft_putstr("KO\n");
}

int	main(int ac, char **av)
{
	t_stack_node	*a;
	t_stack_node	*b;
	char			**split_av;

	a = NULL;
	b = NULL;
	if (ac == 1)
		return (0);
	split_av = split_args(ac - 1, av + 1);
	if (!split_av || !*split_av)
		clean_and_exit(&a, &b, 1);
	init_stack_a(&a, split_av, split_av);
	free_strs(split_av);
	execute_commands(&a, &b);
	check_result(a, b);
	clean_and_exit(&a, &b, 0);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checker.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:38:41 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 21:20:35 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CHECKER_H
# define CHECKER_H
# include "../push_swap.h"

# define BUFFER_SIZE 42

// Checker main
void	checker(t_stack_node **a, t_stack_node **b);

// Command execution
void	execute_commands(t_stack_node **a, t_stack_node **b);
int		execute(char *cmd, t_stack_node **a, t_stack_node **b);

int	ft_strncmp(const char *s1, const char *s2, size_t n);
int	ft_strcmp(char *s1, char *s2);

// GNL
char	*get_next_line(int fd);
char	*gnl_strjoin(char *s1, char *s2);
int		gnl_strchr(char *s, char c);
size_t	gnl_strlen(char *s);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_commands.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 21:18:56 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 21:48:48 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"

int	ft_strcmp(char *s1, char *s2)
{
	unsigned int	i;

	i = 0;
	while (s2[i] && s1[i] && (s1[i] == s2[i]))
	{
		i++;
	}
	return (s1[i] - s2[i]);
}

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (s1[i] && s2[i] && s1[i] == s2[i] && i < n - 1)
	{
		i++;
	}
	return ((unsigned char)s1[i] -(unsigned char)s2[i]);
}

static int	is_valid(char *cmd)
{
	const char	*cmds[] = {"pa\n", "pb\n", "sa\n", "sb\n", "ss\n",
		"ra\n", "rb\n", "rr\n", "rra\n", "rrb\n", "rrr\n", NULL};
	int			i;

	i = -1;
	while (cmds[++i])
		if (!ft_strncmp(cmd, cmds[i], ft_strlen(cmds[i])))
			return (1);
	return (0);
}

int	execute(char *cmd, t_stack_node **a, t_stack_node **b)
{
	if (!ft_strcmp(cmd, "pa\n")) return (pa(a, b, 1), 1);
	if (!ft_strcmp(cmd, "pb\n")) return (pb(b, a, 1), 1);
	if (!ft_strcmp(cmd, "sa\n")) return (sa(a, 1), 1);
	if (!ft_strcmp(cmd, "sb\n")) return (sb(b, 1), 1);
	if (!ft_strcmp(cmd, "ss\n")) return (ss(a, b, 1), 1);
	if (!ft_strcmp(cmd, "ra\n")) return (ra(a, 1), 1);
	if (!ft_strcmp(cmd, "rb\n")) return (rb(b, 1), 1);
	if (!ft_strcmp(cmd, "rr\n")) return (rr(a, b, 1), 1);
	if (!ft_strcmp(cmd, "rra\n")) return (rra(a, 1), 1);
	if (!ft_strcmp(cmd, "rrb\n")) return (rrb(b, 1), 1);
	if (!ft_strcmp(cmd, "rrr\n")) return (rrr(a, b, 1), 1);
	return (0);
}

static void	clean_and_exit(t_stack_node **a, t_stack_node **b, int status)
{
	free_stack(a);
	free_stack(b);
	if (status == 1)
		ft_putstr("Error\n");
	exit(status);
}

// void	execute_commands(t_stack_node **a, t_stack_node **b)
// {
// 	char	*cmd;

// 	cmd = get_next_line(0);
// 	while (cmd)
// 	{
// 		if (!is_valid(cmd) || !execute(cmd, a, b))
// 		{
// 			free(cmd);
// 			clean_and_exit(a, b, 1);
// 		}
// 		free(cmd);
// 		cmd = get_next_line(0);
// 	}
// 	free(cmd);
// }

void	execute_commands(t_stack_node **a, t_stack_node **b)
{
	char	*cmd;

	cmd = get_next_line(0);
	while (cmd)
	{
		// Skip empty lines or lines with only a newline
		if (cmd[0] == '\0' || (cmd[0] == '\n' && cmd[1] == '\0'))
		{
			free(cmd);
			cmd = get_next_line(0);
			continue;
		}
		if (!is_valid(cmd) || !execute(cmd, a, b))
		{
			free(cmd);
			clean_and_exit(a, b, 1);
		}
		free(cmd);
		cmd = get_next_line(0);
	}
	free(cmd);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:36:07 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 21:40:54 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"

char	*get_next_line(int fd)
{
	static char	*buf;
	char		*line;
	int			read_size;
	char		temp[BUFFER_SIZE + 1];

	if (fd < 0 || BUFFER_SIZE < 1)
		return (NULL);

	// Read from the file descriptor until a newline is found
	while (!gnl_strchr(buf, '\n'))
	{
		read_size = read(fd, temp, BUFFER_SIZE);
		if (read_size < 0)
			return (free(buf), buf = NULL, NULL); // Free buffer on read error
		if (read_size == 0)
			break ; // End of file
		temp[read_size] = 0;
		buf = gnl_strjoin(buf, temp); // Append new data to the buffer
	}

	if (!buf)
		return (NULL); // No data to process

	// Extract the line up to the newline
	line = gnl_strjoin(NULL, buf);
	if (!line)
		return (free(buf), buf = NULL, NULL); // Free buffer on allocation failure

	// Update the buffer to remove the extracted line
	if (gnl_strchr(buf, '\n'))
	{
		char *new_buf = gnl_strjoin(NULL, buf + gnl_strlen(line));
		free(buf); // Free the old buffer
		buf = new_buf; // Update the buffer with the remaining content
	}
	else
	{
		free(buf); // Free the buffer if no more lines are left
		buf = NULL;
	}

	return (line);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:36:10 by ymazini           #+#    #+#             */
/*   Updated: 2025/01/31 21:41:08 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"

size_t	gnl_strlen(char *s)
{
	size_t	i;

	i = 0;
	while (s && s[i])
		i++;
	return (i);
}

int	gnl_strchr(char *s, char c)
{
	int	i;

	i = -1;
	while (s && s[++i])
		if (s[i] == c)
			return (1);
	return (0);
}

char	*gnl_strjoin(char *s1, char *s2)
{
	char	*new;
	int		i;
	int		j;

	new = malloc(gnl_strlen(s1) + gnl_strlen(s2) + 1);
	if (!new)
		return (NULL); // Do not free s1 here

	i = 0;
	j = 0;
	while (s1 && s1[j])
		new[i++] = s1[j++];
	j = 0;
	while (s2 && s2[j])
		new[i++] = s2[j++];
	new[i] = 0;

	return (new);
}
